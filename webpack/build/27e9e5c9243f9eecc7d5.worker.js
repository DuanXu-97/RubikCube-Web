/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/build/";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	var Cube = __webpack_require__(1);
	__webpack_require__(3);

	self.addEventListener("message", function (e) {
	  if (e.data.name !== "solve") return;
	  var state = e.data.state;

	  // Slice our state into faces, so it's easy to manipulate
	  var faces = {};
	  "ULFRBD".split("").forEach(function (face, idx) {
	    faces[face] = state.substring(idx*9, (idx+1)*9);
	  });

	  // Map our state to an unrotated one
	  var mapping = {};
	  Object.keys(faces).forEach(function (face) {
	    mapping[faces[face][4]] = face;
	  });
	  Object.keys(faces).forEach(function (face) {
	    faces[face] = faces[face].split("").map(function (c) {
	      return (c in mapping) ? mapping[c] : c;
	    }).join("");
	  });

	  // Solve!
	  var cst = "URFDLB".split("").map(function (face) {
	    return faces[face];
	  }).join("");
	  var alg = Cube.fromString(cst).solve();

	  self.postMessage({ name: "solved", state: state, alg: alg });
	});

	Cube.initSolver();
	self.postMessage({ name: "ready" });


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {// Generated by CoffeeScript 1.10.0
	(function() {
	  var BL, BR, Cube, DB, DBL, DF, DFR, DL, DLF, DR, DRB, FL, FR, UB, UBR, UF, UFL, UL, ULB, UR, URF, cornerColor, cornerFacelet, edgeColor, edgeFacelet, ref, ref1, ref2;

	  ref = [0, 1, 2, 3, 4, 5, 6, 7], URF = ref[0], UFL = ref[1], ULB = ref[2], UBR = ref[3], DFR = ref[4], DLF = ref[5], DBL = ref[6], DRB = ref[7];

	  ref1 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], UR = ref1[0], UF = ref1[1], UL = ref1[2], UB = ref1[3], DR = ref1[4], DF = ref1[5], DL = ref1[6], DB = ref1[7], FR = ref1[8], FL = ref1[9], BL = ref1[10], BR = ref1[11];

	  ref2 = (function() {
	    var B, D, F, L, R, U;
	    U = function(x) {
	      return x - 1;
	    };
	    R = function(x) {
	      return U(9) + x;
	    };
	    F = function(x) {
	      return R(9) + x;
	    };
	    D = function(x) {
	      return F(9) + x;
	    };
	    L = function(x) {
	      return D(9) + x;
	    };
	    B = function(x) {
	      return L(9) + x;
	    };
	    return [[[U(9), R(1), F(3)], [U(7), F(1), L(3)], [U(1), L(1), B(3)], [U(3), B(1), R(3)], [D(3), F(9), R(7)], [D(1), L(9), F(7)], [D(7), B(9), L(7)], [D(9), R(9), B(7)]], [[U(6), R(2)], [U(8), F(2)], [U(4), L(2)], [U(2), B(2)], [D(6), R(8)], [D(2), F(8)], [D(4), L(8)], [D(8), B(8)], [F(6), R(4)], [F(4), L(6)], [B(6), L(4)], [B(4), R(6)]]];
	  })(), cornerFacelet = ref2[0], edgeFacelet = ref2[1];

	  cornerColor = [['U', 'R', 'F'], ['U', 'F', 'L'], ['U', 'L', 'B'], ['U', 'B', 'R'], ['D', 'F', 'R'], ['D', 'L', 'F'], ['D', 'B', 'L'], ['D', 'R', 'B']];

	  edgeColor = [['U', 'R'], ['U', 'F'], ['U', 'L'], ['U', 'B'], ['D', 'R'], ['D', 'F'], ['D', 'L'], ['D', 'B'], ['F', 'R'], ['F', 'L'], ['B', 'L'], ['B', 'R']];

	  Cube = (function() {
	    var faceNames, faceNums, parseAlg;

	    function Cube(other) {
	      var x;
	      if (other != null) {
	        this.init(other);
	      } else {
	        this.identity();
	      }
	      this.newCp = (function() {
	        var k, results;
	        results = [];
	        for (x = k = 0; k <= 7; x = ++k) {
	          results.push(0);
	        }
	        return results;
	      })();
	      this.newEp = (function() {
	        var k, results;
	        results = [];
	        for (x = k = 0; k <= 11; x = ++k) {
	          results.push(0);
	        }
	        return results;
	      })();
	      this.newCo = (function() {
	        var k, results;
	        results = [];
	        for (x = k = 0; k <= 7; x = ++k) {
	          results.push(0);
	        }
	        return results;
	      })();
	      this.newEo = (function() {
	        var k, results;
	        results = [];
	        for (x = k = 0; k <= 11; x = ++k) {
	          results.push(0);
	        }
	        return results;
	      })();
	    }

	    Cube.prototype.init = function(state) {
	      this.cp = state.cp.slice(0);
	      this.co = state.co.slice(0);
	      this.ep = state.ep.slice(0);
	      return this.eo = state.eo.slice(0);
	    };

	    Cube.prototype.identity = function() {
	      var x;
	      this.cp = [0, 1, 2, 3, 4, 5, 6, 7];
	      this.co = (function() {
	        var k, results;
	        results = [];
	        for (x = k = 0; k <= 7; x = ++k) {
	          results.push(0);
	        }
	        return results;
	      })();
	      this.ep = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
	      return this.eo = (function() {
	        var k, results;
	        results = [];
	        for (x = k = 0; k <= 11; x = ++k) {
	          results.push(0);
	        }
	        return results;
	      })();
	    };

	    Cube.prototype.toJSON = function() {
	      return {
	        cp: this.cp,
	        co: this.co,
	        ep: this.ep,
	        eo: this.eo
	      };
	    };

	    Cube.prototype.asString = function() {
	      var c, corner, edge, i, k, l, len, m, n, o, ori, p, ref3, ref4, result;
	      result = [];
	      ref3 = [[4, 'U'], [13, 'R'], [22, 'F'], [31, 'D'], [40, 'L'], [49, 'B']];
	      for (k = 0, len = ref3.length; k < len; k++) {
	        ref4 = ref3[k], i = ref4[0], c = ref4[1];
	        result[i] = c;
	      }
	      for (i = l = 0; l <= 7; i = ++l) {
	        corner = this.cp[i];
	        ori = this.co[i];
	        for (n = m = 0; m <= 2; n = ++m) {
	          result[cornerFacelet[i][(n + ori) % 3]] = cornerColor[corner][n];
	        }
	      }
	      for (i = o = 0; o <= 11; i = ++o) {
	        edge = this.ep[i];
	        ori = this.eo[i];
	        for (n = p = 0; p <= 1; n = ++p) {
	          result[edgeFacelet[i][(n + ori) % 2]] = edgeColor[edge][n];
	        }
	      }
	      return result.join('');
	    };

	    Cube.fromString = function(str) {
	      var col1, col2, cube, i, j, k, l, m, o, ori, p, ref3;
	      cube = new Cube;
	      for (i = k = 0; k <= 7; i = ++k) {
	        for (ori = l = 0; l <= 2; ori = ++l) {
	          if ((ref3 = str[cornerFacelet[i][ori]]) === 'U' || ref3 === 'D') {
	            break;
	          }
	        }
	        col1 = str[cornerFacelet[i][(ori + 1) % 3]];
	        col2 = str[cornerFacelet[i][(ori + 2) % 3]];
	        for (j = m = 0; m <= 7; j = ++m) {
	          if (col1 === cornerColor[j][1] && col2 === cornerColor[j][2]) {
	            cube.cp[i] = j;
	            cube.co[i] = ori % 3;
	          }
	        }
	      }
	      for (i = o = 0; o <= 11; i = ++o) {
	        for (j = p = 0; p <= 11; j = ++p) {
	          if (str[edgeFacelet[i][0]] === edgeColor[j][0] && str[edgeFacelet[i][1]] === edgeColor[j][1]) {
	            cube.ep[i] = j;
	            cube.eo[i] = 0;
	            break;
	          }
	          if (str[edgeFacelet[i][0]] === edgeColor[j][1] && str[edgeFacelet[i][1]] === edgeColor[j][0]) {
	            cube.ep[i] = j;
	            cube.eo[i] = 1;
	            break;
	          }
	        }
	      }
	      return cube;
	    };

	    Cube.prototype.clone = function() {
	      return new Cube(this.toJSON());
	    };

	    Cube.prototype.randomize = (function() {
	      var mixPerm, randOri, randint, result;
	      randint = function(min, max) {
	        return min + (Math.random() * (max - min + 1) | 0);
	      };
	      mixPerm = function(arr) {
	        var i, k, max, r, ref3, ref4, ref5, results;
	        max = arr.length - 1;
	        results = [];
	        for (i = k = 0, ref3 = max - 2; 0 <= ref3 ? k <= ref3 : k >= ref3; i = 0 <= ref3 ? ++k : --k) {
	          r = randint(i, max);
	          if (i !== r) {
	            ref4 = [arr[r], arr[i]], arr[i] = ref4[0], arr[r] = ref4[1];
	            results.push((ref5 = [arr[max - 1], arr[max]], arr[max] = ref5[0], arr[max - 1] = ref5[1], ref5));
	          } else {
	            results.push(void 0);
	          }
	        }
	        return results;
	      };
	      randOri = function(arr, max) {
	        var i, k, ori, ref3;
	        ori = 0;
	        for (i = k = 0, ref3 = arr.length - 2; 0 <= ref3 ? k <= ref3 : k >= ref3; i = 0 <= ref3 ? ++k : --k) {
	          ori += (arr[i] = randint(0, max - 1));
	        }
	        return arr[arr.length - 1] = (max - ori % max) % max;
	      };
	      result = function() {
	        mixPerm(this.cp);
	        mixPerm(this.ep);
	        randOri(this.co, 3);
	        randOri(this.eo, 2);
	        return this;
	      };
	      return result;
	    })();

	    Cube.random = function() {
	      return (new Cube).randomize();
	    };

	    Cube.prototype.isSolved = function() {
	      var c, e, k, l;
	      for (c = k = 0; k <= 7; c = ++k) {
	        if (this.cp[c] !== c) {
	          return false;
	        }
	        if (this.co[c] !== 0) {
	          return false;
	        }
	      }
	      for (e = l = 0; l <= 11; e = ++l) {
	        if (this.ep[e] !== e) {
	          return false;
	        }
	        if (this.eo[e] !== 0) {
	          return false;
	        }
	      }
	      return true;
	    };

	    Cube.prototype.cornerMultiply = function(other) {
	      var from, k, ref3, ref4, to;
	      for (to = k = 0; k <= 7; to = ++k) {
	        from = other.cp[to];
	        this.newCp[to] = this.cp[from];
	        this.newCo[to] = (this.co[from] + other.co[to]) % 3;
	      }
	      ref3 = [this.newCp, this.cp], this.cp = ref3[0], this.newCp = ref3[1];
	      ref4 = [this.newCo, this.co], this.co = ref4[0], this.newCo = ref4[1];
	      return this;
	    };

	    Cube.prototype.edgeMultiply = function(other) {
	      var from, k, ref3, ref4, to;
	      for (to = k = 0; k <= 11; to = ++k) {
	        from = other.ep[to];
	        this.newEp[to] = this.ep[from];
	        this.newEo[to] = (this.eo[from] + other.eo[to]) % 2;
	      }
	      ref3 = [this.newEp, this.ep], this.ep = ref3[0], this.newEp = ref3[1];
	      ref4 = [this.newEo, this.eo], this.eo = ref4[0], this.newEo = ref4[1];
	      return this;
	    };

	    Cube.prototype.multiply = function(other) {
	      this.cornerMultiply(other);
	      this.edgeMultiply(other);
	      return this;
	    };

	    Cube.moves = [
	      {
	        cp: [UBR, URF, UFL, ULB, DFR, DLF, DBL, DRB],
	        co: [0, 0, 0, 0, 0, 0, 0, 0],
	        ep: [UB, UR, UF, UL, DR, DF, DL, DB, FR, FL, BL, BR],
	        eo: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
	      }, {
	        cp: [DFR, UFL, ULB, URF, DRB, DLF, DBL, UBR],
	        co: [2, 0, 0, 1, 1, 0, 0, 2],
	        ep: [FR, UF, UL, UB, BR, DF, DL, DB, DR, FL, BL, UR],
	        eo: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
	      }, {
	        cp: [UFL, DLF, ULB, UBR, URF, DFR, DBL, DRB],
	        co: [1, 2, 0, 0, 2, 1, 0, 0],
	        ep: [UR, FL, UL, UB, DR, FR, DL, DB, UF, DF, BL, BR],
	        eo: [0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0]
	      }, {
	        cp: [URF, UFL, ULB, UBR, DLF, DBL, DRB, DFR],
	        co: [0, 0, 0, 0, 0, 0, 0, 0],
	        ep: [UR, UF, UL, UB, DF, DL, DB, DR, FR, FL, BL, BR],
	        eo: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
	      }, {
	        cp: [URF, ULB, DBL, UBR, DFR, UFL, DLF, DRB],
	        co: [0, 1, 2, 0, 0, 2, 1, 0],
	        ep: [UR, UF, BL, UB, DR, DF, FL, DB, FR, UL, DL, BR],
	        eo: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
	      }, {
	        cp: [URF, UFL, UBR, DRB, DFR, DLF, ULB, DBL],
	        co: [0, 0, 1, 2, 0, 0, 2, 1],
	        ep: [UR, UF, UL, BR, DR, DF, DL, BL, FR, FL, UB, DB],
	        eo: [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1]
	      }
	    ];

	    faceNums = {
	      U: 0,
	      R: 1,
	      F: 2,
	      D: 3,
	      L: 4,
	      B: 5
	    };

	    faceNames = {
	      0: 'U',
	      1: 'R',
	      2: 'F',
	      3: 'D',
	      4: 'L',
	      5: 'B'
	    };

	    parseAlg = function(arg) {
	      var k, len, move, part, power, ref3, results;
	      if (typeof arg === 'string') {
	        ref3 = arg.split(/\s+/);
	        results = [];
	        for (k = 0, len = ref3.length; k < len; k++) {
	          part = ref3[k];
	          if (part.length === 0) {
	            continue;
	          }
	          if (part.length > 2) {
	            throw 'Invalid move: ' + part;
	          }
	          move = faceNums[part[0]];
	          if (move === void 0) {
	            throw 'Invalid move: ' + part;
	          }
	          if (part.length === 1) {
	            power = 0;
	          } else {
	            if (part[1] === '2') {
	              power = 1;
	            } else if (part[1] === "'") {
	              power = 2;
	            } else {
	              throw 'Invalid move: ' + part;
	            }
	          }
	          results.push(move * 3 + power);
	        }
	        return results;
	      } else if (arg.length != null) {
	        return arg;
	      } else {
	        return [arg];
	      }
	    };

	    Cube.prototype.move = function(arg) {
	      var face, k, l, len, move, power, ref3, ref4, x;
	      ref3 = parseAlg(arg);
	      for (k = 0, len = ref3.length; k < len; k++) {
	        move = ref3[k];
	        face = move / 3 | 0;
	        power = move % 3;
	        for (x = l = 0, ref4 = power; 0 <= ref4 ? l <= ref4 : l >= ref4; x = 0 <= ref4 ? ++l : --l) {
	          this.multiply(Cube.moves[face]);
	        }
	      }
	      return this;
	    };

	    Cube.inverse = function(arg) {
	      var face, k, len, move, power, result, str;
	      result = (function() {
	        var k, len, ref3, results;
	        ref3 = parseAlg(arg);
	        results = [];
	        for (k = 0, len = ref3.length; k < len; k++) {
	          move = ref3[k];
	          face = move / 3 | 0;
	          power = move % 3;
	          results.push(face * 3 + -(power - 1) + 1);
	        }
	        return results;
	      })();
	      result.reverse();
	      if (typeof arg === 'string') {
	        str = '';
	        for (k = 0, len = result.length; k < len; k++) {
	          move = result[k];
	          face = move / 3 | 0;
	          power = move % 3;
	          str += faceNames[face];
	          if (power === 1) {
	            str += '2';
	          } else if (power === 2) {
	            str += "'";
	          }
	          str += ' ';
	        }
	        return str.substring(0, str.length - 1);
	      } else if (arg.length != null) {
	        return result;
	      } else {
	        return result[0];
	      }
	    };

	    return Cube;

	  })();

	  if (typeof module !== "undefined" && module !== null) {
	    module.exports = Cube;
	  } else {
	    this.Cube = Cube;
	  }

	}).call(this);

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)(module)))

/***/ }),
/* 2 */
/***/ (function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

	// Generated by CoffeeScript 1.10.0
	(function() {
	  var BL, BR, Cnk, Cube, DB, DBL, DF, DFR, DL, DLF, DR, DRB, FL, FR, Include, N_FLIP, N_FRtoBR, N_PARITY, N_SLICE1, N_SLICE2, N_TWIST, N_UBtoDF, N_URFtoDLF, N_URtoDF, N_URtoUL, UB, UBR, UF, UFL, UL, ULB, UR, URF, allMoves1, allMoves2, computeMoveTable, computePruningTable, factorial, key, max, mergeURtoDF, moveTableParams, nextMoves1, nextMoves2, permutationIndex, pruning, pruningTableParams, ref, ref1, rotateLeft, rotateRight, value,
	    slice1 = [].slice,
	    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

	  Cube = this.Cube || __webpack_require__(1);

	  ref = [0, 1, 2, 3, 4, 5, 6, 7], URF = ref[0], UFL = ref[1], ULB = ref[2], UBR = ref[3], DFR = ref[4], DLF = ref[5], DBL = ref[6], DRB = ref[7];

	  ref1 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], UR = ref1[0], UF = ref1[1], UL = ref1[2], UB = ref1[3], DR = ref1[4], DF = ref1[5], DL = ref1[6], DB = ref1[7], FR = ref1[8], FL = ref1[9], BL = ref1[10], BR = ref1[11];

	  Cnk = function(n, k) {
	    var i, j, s;
	    if (n < k) {
	      return 0;
	    }
	    if (k > n / 2) {
	      k = n - k;
	    }
	    s = 1;
	    i = n;
	    j = 1;
	    while (i !== n - k) {
	      s *= i;
	      s /= j;
	      i--;
	      j++;
	    }
	    return s;
	  };

	  factorial = function(n) {
	    var f, i, m, ref2;
	    f = 1;
	    for (i = m = 2, ref2 = n; 2 <= ref2 ? m <= ref2 : m >= ref2; i = 2 <= ref2 ? ++m : --m) {
	      f *= i;
	    }
	    return f;
	  };

	  max = function(a, b) {
	    if (a > b) {
	      return a;
	    } else {
	      return b;
	    }
	  };

	  rotateLeft = function(array, l, r) {
	    var i, m, ref2, ref3, tmp;
	    tmp = array[l];
	    for (i = m = ref2 = l, ref3 = r - 1; ref2 <= ref3 ? m <= ref3 : m >= ref3; i = ref2 <= ref3 ? ++m : --m) {
	      array[i] = array[i + 1];
	    }
	    return array[r] = tmp;
	  };

	  rotateRight = function(array, l, r) {
	    var i, m, ref2, ref3, tmp;
	    tmp = array[r];
	    for (i = m = ref2 = r, ref3 = l + 1; ref2 <= ref3 ? m <= ref3 : m >= ref3; i = ref2 <= ref3 ? ++m : --m) {
	      array[i] = array[i - 1];
	    }
	    return array[l] = tmp;
	  };

	  permutationIndex = function(context, start, end, fromEnd) {
	    var i, maxAll, maxB, maxOur, our, permName;
	    if (fromEnd == null) {
	      fromEnd = false;
	    }
	    maxOur = end - start;
	    maxB = factorial(maxOur + 1);
	    if (context === 'corners') {
	      maxAll = 7;
	      permName = 'cp';
	    } else {
	      maxAll = 11;
	      permName = 'ep';
	    }
	    our = (function() {
	      var m, ref2, results;
	      results = [];
	      for (i = m = 0, ref2 = maxOur; 0 <= ref2 ? m <= ref2 : m >= ref2; i = 0 <= ref2 ? ++m : --m) {
	        results.push(0);
	      }
	      return results;
	    })();
	    return function(index) {
	      var a, b, c, j, k, m, o, p, perm, q, ref10, ref11, ref12, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, t, u, w, x, y, z;
	      if (index != null) {
	        for (i = m = 0, ref2 = maxOur; 0 <= ref2 ? m <= ref2 : m >= ref2; i = 0 <= ref2 ? ++m : --m) {
	          our[i] = i + start;
	        }
	        b = index % maxB;
	        a = index / maxB | 0;
	        perm = this[permName];
	        for (i = o = 0, ref3 = maxAll; 0 <= ref3 ? o <= ref3 : o >= ref3; i = 0 <= ref3 ? ++o : --o) {
	          perm[i] = -1;
	        }
	        for (j = p = 1, ref4 = maxOur; 1 <= ref4 ? p <= ref4 : p >= ref4; j = 1 <= ref4 ? ++p : --p) {
	          k = b % (j + 1);
	          b = b / (j + 1) | 0;
	          while (k > 0) {
	            rotateRight(our, 0, j);
	            k--;
	          }
	        }
	        x = maxOur;
	        if (fromEnd) {
	          for (j = q = 0, ref5 = maxAll; 0 <= ref5 ? q <= ref5 : q >= ref5; j = 0 <= ref5 ? ++q : --q) {
	            c = Cnk(maxAll - j, x + 1);
	            if (a - c >= 0) {
	              perm[j] = our[maxOur - x];
	              a -= c;
	              x--;
	            }
	          }
	        } else {
	          for (j = t = ref6 = maxAll; ref6 <= 0 ? t <= 0 : t >= 0; j = ref6 <= 0 ? ++t : --t) {
	            c = Cnk(j, x + 1);
	            if (a - c >= 0) {
	              perm[j] = our[x];
	              a -= c;
	              x--;
	            }
	          }
	        }
	        return this;
	      } else {
	        perm = this[permName];
	        for (i = u = 0, ref7 = maxOur; 0 <= ref7 ? u <= ref7 : u >= ref7; i = 0 <= ref7 ? ++u : --u) {
	          our[i] = -1;
	        }
	        a = b = x = 0;
	        if (fromEnd) {
	          for (j = w = ref8 = maxAll; ref8 <= 0 ? w <= 0 : w >= 0; j = ref8 <= 0 ? ++w : --w) {
	            if ((start <= (ref9 = perm[j]) && ref9 <= end)) {
	              a += Cnk(maxAll - j, x + 1);
	              our[maxOur - x] = perm[j];
	              x++;
	            }
	          }
	        } else {
	          for (j = y = 0, ref10 = maxAll; 0 <= ref10 ? y <= ref10 : y >= ref10; j = 0 <= ref10 ? ++y : --y) {
	            if ((start <= (ref11 = perm[j]) && ref11 <= end)) {
	              a += Cnk(j, x + 1);
	              our[x] = perm[j];
	              x++;
	            }
	          }
	        }
	        for (j = z = ref12 = maxOur; ref12 <= 0 ? z <= 0 : z >= 0; j = ref12 <= 0 ? ++z : --z) {
	          k = 0;
	          while (our[j] !== start + j) {
	            rotateLeft(our, 0, j);
	            k++;
	          }
	          b = (j + 1) * b + k;
	        }
	        return a * maxB + b;
	      }
	    };
	  };

	  Include = {
	    twist: function(twist) {
	      var i, m, o, ori, parity, v;
	      if (twist != null) {
	        parity = 0;
	        for (i = m = 6; m >= 0; i = --m) {
	          ori = twist % 3;
	          twist = (twist / 3) | 0;
	          this.co[i] = ori;
	          parity += ori;
	        }
	        this.co[7] = (3 - parity % 3) % 3;
	        return this;
	      } else {
	        v = 0;
	        for (i = o = 0; o <= 6; i = ++o) {
	          v = 3 * v + this.co[i];
	        }
	        return v;
	      }
	    },
	    flip: function(flip) {
	      var i, m, o, ori, parity, v;
	      if (flip != null) {
	        parity = 0;
	        for (i = m = 10; m >= 0; i = --m) {
	          ori = flip % 2;
	          flip = flip / 2 | 0;
	          this.eo[i] = ori;
	          parity += ori;
	        }
	        this.eo[11] = (2 - parity % 2) % 2;
	        return this;
	      } else {
	        v = 0;
	        for (i = o = 0; o <= 10; i = ++o) {
	          v = 2 * v + this.eo[i];
	        }
	        return v;
	      }
	    },
	    cornerParity: function() {
	      var i, j, m, o, ref2, ref3, ref4, ref5, s;
	      s = 0;
	      for (i = m = ref2 = DRB, ref3 = URF + 1; ref2 <= ref3 ? m <= ref3 : m >= ref3; i = ref2 <= ref3 ? ++m : --m) {
	        for (j = o = ref4 = i - 1, ref5 = URF; ref4 <= ref5 ? o <= ref5 : o >= ref5; j = ref4 <= ref5 ? ++o : --o) {
	          if (this.cp[j] > this.cp[i]) {
	            s++;
	          }
	        }
	      }
	      return s % 2;
	    },
	    edgeParity: function() {
	      var i, j, m, o, ref2, ref3, ref4, ref5, s;
	      s = 0;
	      for (i = m = ref2 = BR, ref3 = UR + 1; ref2 <= ref3 ? m <= ref3 : m >= ref3; i = ref2 <= ref3 ? ++m : --m) {
	        for (j = o = ref4 = i - 1, ref5 = UR; ref4 <= ref5 ? o <= ref5 : o >= ref5; j = ref4 <= ref5 ? ++o : --o) {
	          if (this.ep[j] > this.ep[i]) {
	            s++;
	          }
	        }
	      }
	      return s % 2;
	    },
	    URFtoDLF: permutationIndex('corners', URF, DLF),
	    URtoUL: permutationIndex('edges', UR, UL),
	    UBtoDF: permutationIndex('edges', UB, DF),
	    URtoDF: permutationIndex('edges', UR, DF),
	    FRtoBR: permutationIndex('edges', FR, BR, true)
	  };

	  for (key in Include) {
	    value = Include[key];
	    Cube.prototype[key] = value;
	  }

	  computeMoveTable = function(context, coord, size) {
	    var apply, cube, i, inner, j, k, m, move, o, p, ref2, results;
	    apply = context === 'corners' ? 'cornerMultiply' : 'edgeMultiply';
	    cube = new Cube;
	    results = [];
	    for (i = m = 0, ref2 = size - 1; 0 <= ref2 ? m <= ref2 : m >= ref2; i = 0 <= ref2 ? ++m : --m) {
	      cube[coord](i);
	      inner = [];
	      for (j = o = 0; o <= 5; j = ++o) {
	        move = Cube.moves[j];
	        for (k = p = 0; p <= 2; k = ++p) {
	          cube[apply](move);
	          inner.push(cube[coord]());
	        }
	        cube[apply](move);
	      }
	      results.push(inner);
	    }
	    return results;
	  };

	  mergeURtoDF = (function() {
	    var a, b;
	    a = new Cube;
	    b = new Cube;
	    return function(URtoUL, UBtoDF) {
	      var i, m;
	      a.URtoUL(URtoUL);
	      b.UBtoDF(UBtoDF);
	      for (i = m = 0; m <= 7; i = ++m) {
	        if (a.ep[i] !== -1) {
	          if (b.ep[i] !== -1) {
	            return -1;
	          } else {
	            b.ep[i] = a.ep[i];
	          }
	        }
	      }
	      return b.URtoDF();
	    };
	  })();

	  N_TWIST = 2187;

	  N_FLIP = 2048;

	  N_PARITY = 2;

	  N_FRtoBR = 11880;

	  N_SLICE1 = 495;

	  N_SLICE2 = 24;

	  N_URFtoDLF = 20160;

	  N_URtoDF = 20160;

	  N_URtoUL = 1320;

	  N_UBtoDF = 1320;

	  Cube.moveTables = {
	    parity: [[1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1], [0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0]],
	    twist: null,
	    flip: null,
	    FRtoBR: null,
	    URFtoDLF: null,
	    URtoDF: null,
	    URtoUL: null,
	    UBtoDF: null,
	    mergeURtoDF: null
	  };

	  moveTableParams = {
	    twist: ['corners', N_TWIST],
	    flip: ['edges', N_FLIP],
	    FRtoBR: ['edges', N_FRtoBR],
	    URFtoDLF: ['corners', N_URFtoDLF],
	    URtoDF: ['edges', N_URtoDF],
	    URtoUL: ['edges', N_URtoUL],
	    UBtoDF: ['edges', N_UBtoDF],
	    mergeURtoDF: []
	  };

	  Cube.computeMoveTables = function() {
	    var len, m, name, ref2, scope, size, tableName, tables;
	    tables = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
	    if (tables.length === 0) {
	      tables = (function() {
	        var results;
	        results = [];
	        for (name in moveTableParams) {
	          results.push(name);
	        }
	        return results;
	      })();
	    }
	    for (m = 0, len = tables.length; m < len; m++) {
	      tableName = tables[m];
	      if (this.moveTables[tableName] !== null) {
	        continue;
	      }
	      if (tableName === 'mergeURtoDF') {
	        this.moveTables.mergeURtoDF = (function() {
	          var UBtoDF, URtoUL, o, results;
	          results = [];
	          for (URtoUL = o = 0; o <= 335; URtoUL = ++o) {
	            results.push((function() {
	              var p, results1;
	              results1 = [];
	              for (UBtoDF = p = 0; p <= 335; UBtoDF = ++p) {
	                results1.push(mergeURtoDF(URtoUL, UBtoDF));
	              }
	              return results1;
	            })());
	          }
	          return results;
	        })();
	      } else {
	        ref2 = moveTableParams[tableName], scope = ref2[0], size = ref2[1];
	        this.moveTables[tableName] = computeMoveTable(scope, tableName, size);
	      }
	    }
	    return this;
	  };

	  allMoves1 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17];

	  nextMoves1 = (function() {
	    var face, lastFace, m, next, o, p, power, results;
	    results = [];
	    for (lastFace = m = 0; m <= 5; lastFace = ++m) {
	      next = [];
	      for (face = o = 0; o <= 5; face = ++o) {
	        if (face !== lastFace && face !== lastFace - 3) {
	          for (power = p = 0; p <= 2; power = ++p) {
	            next.push(face * 3 + power);
	          }
	        }
	      }
	      results.push(next);
	    }
	    return results;
	  })();

	  allMoves2 = [0, 1, 2, 4, 7, 9, 10, 11, 13, 16];

	  nextMoves2 = (function() {
	    var face, lastFace, len, m, next, o, p, power, powers, results;
	    results = [];
	    for (lastFace = m = 0; m <= 5; lastFace = ++m) {
	      next = [];
	      for (face = o = 0; o <= 5; face = ++o) {
	        if (!(face !== lastFace && face !== lastFace - 3)) {
	          continue;
	        }
	        powers = face === 0 || face === 3 ? [0, 1, 2] : [1];
	        for (p = 0, len = powers.length; p < len; p++) {
	          power = powers[p];
	          next.push(face * 3 + power);
	        }
	      }
	      results.push(next);
	    }
	    return results;
	  })();

	  pruning = function(table, index, value) {
	    var pos, shift, slot;
	    pos = index % 8;
	    slot = index >> 3;
	    shift = pos << 2;
	    if (value != null) {
	      table[slot] &= ~(0xF << shift);
	      table[slot] |= value << shift;
	      return value;
	    } else {
	      return (table[slot] & (0xF << shift)) >>> shift;
	    }
	  };

	  computePruningTable = function(phase, size, currentCoords, nextIndex) {
	    var current, depth, done, index, len, m, move, moves, next, o, ref2, table, x;
	    table = (function() {
	      var m, ref2, results;
	      results = [];
	      for (x = m = 0, ref2 = Math.ceil(size / 8) - 1; 0 <= ref2 ? m <= ref2 : m >= ref2; x = 0 <= ref2 ? ++m : --m) {
	        results.push(0xFFFFFFFF);
	      }
	      return results;
	    })();
	    if (phase === 1) {
	      moves = allMoves1;
	    } else {
	      moves = allMoves2;
	    }
	    depth = 0;
	    pruning(table, 0, depth);
	    done = 1;
	    while (done !== size) {
	      for (index = m = 0, ref2 = size - 1; 0 <= ref2 ? m <= ref2 : m >= ref2; index = 0 <= ref2 ? ++m : --m) {
	        if (!(pruning(table, index) === depth)) {
	          continue;
	        }
	        current = currentCoords(index);
	        for (o = 0, len = moves.length; o < len; o++) {
	          move = moves[o];
	          next = nextIndex(current, move);
	          if (pruning(table, next) === 0xF) {
	            pruning(table, next, depth + 1);
	            done++;
	          }
	        }
	      }
	      depth++;
	    }
	    return table;
	  };

	  Cube.pruningTables = {
	    sliceTwist: null,
	    sliceFlip: null,
	    sliceURFtoDLFParity: null,
	    sliceURtoDFParity: null
	  };

	  pruningTableParams = {
	    sliceTwist: [
	      1, N_SLICE1 * N_TWIST, function(index) {
	        return [index % N_SLICE1, index / N_SLICE1 | 0];
	      }, function(current, move) {
	        var newSlice, newTwist, slice, twist;
	        slice = current[0], twist = current[1];
	        newSlice = Cube.moveTables.FRtoBR[slice * 24][move] / 24 | 0;
	        newTwist = Cube.moveTables.twist[twist][move];
	        return newTwist * N_SLICE1 + newSlice;
	      }
	    ],
	    sliceFlip: [
	      1, N_SLICE1 * N_FLIP, function(index) {
	        return [index % N_SLICE1, index / N_SLICE1 | 0];
	      }, function(current, move) {
	        var flip, newFlip, newSlice, slice;
	        slice = current[0], flip = current[1];
	        newSlice = Cube.moveTables.FRtoBR[slice * 24][move] / 24 | 0;
	        newFlip = Cube.moveTables.flip[flip][move];
	        return newFlip * N_SLICE1 + newSlice;
	      }
	    ],
	    sliceURFtoDLFParity: [
	      2, N_SLICE2 * N_URFtoDLF * N_PARITY, function(index) {
	        return [index % 2, (index / 2 | 0) % N_SLICE2, (index / 2 | 0) / N_SLICE2 | 0];
	      }, function(current, move) {
	        var URFtoDLF, newParity, newSlice, newURFtoDLF, parity, slice;
	        parity = current[0], slice = current[1], URFtoDLF = current[2];
	        newParity = Cube.moveTables.parity[parity][move];
	        newSlice = Cube.moveTables.FRtoBR[slice][move];
	        newURFtoDLF = Cube.moveTables.URFtoDLF[URFtoDLF][move];
	        return (newURFtoDLF * N_SLICE2 + newSlice) * 2 + newParity;
	      }
	    ],
	    sliceURtoDFParity: [
	      2, N_SLICE2 * N_URtoDF * N_PARITY, function(index) {
	        return [index % 2, (index / 2 | 0) % N_SLICE2, (index / 2 | 0) / N_SLICE2 | 0];
	      }, function(current, move) {
	        var URtoDF, newParity, newSlice, newURtoDF, parity, slice;
	        parity = current[0], slice = current[1], URtoDF = current[2];
	        newParity = Cube.moveTables.parity[parity][move];
	        newSlice = Cube.moveTables.FRtoBR[slice][move];
	        newURtoDF = Cube.moveTables.URtoDF[URtoDF][move];
	        return (newURtoDF * N_SLICE2 + newSlice) * 2 + newParity;
	      }
	    ]
	  };

	  Cube.computePruningTables = function() {
	    var len, m, name, params, tableName, tables;
	    tables = 1 <= arguments.length ? slice1.call(arguments, 0) : [];
	    if (tables.length === 0) {
	      tables = (function() {
	        var results;
	        results = [];
	        for (name in pruningTableParams) {
	          results.push(name);
	        }
	        return results;
	      })();
	    }
	    for (m = 0, len = tables.length; m < len; m++) {
	      tableName = tables[m];
	      if (this.pruningTables[tableName] !== null) {
	        continue;
	      }
	      params = pruningTableParams[tableName];
	      this.pruningTables[tableName] = computePruningTable.apply(null, params);
	    }
	    return this;
	  };

	  Cube.initSolver = function() {
	    Cube.computeMoveTables();
	    return Cube.computePruningTables();
	  };

	  Cube.prototype.solve = function(maxDepth) {
	    var State, freeStates, moveNames, phase1, phase1search, phase2, phase2search, solution, state, x;
	    if (maxDepth == null) {
	      maxDepth = 22;
	    }
	    moveNames = (function() {
	      var face, faceName, m, o, power, powerName, result;
	      faceName = ['U', 'R', 'F', 'D', 'L', 'B'];
	      powerName = ['', '2', "'"];
	      result = [];
	      for (face = m = 0; m <= 5; face = ++m) {
	        for (power = o = 0; o <= 2; power = ++o) {
	          result.push(faceName[face] + powerName[power]);
	        }
	      }
	      return result;
	    })();
	    State = (function() {
	      function State(cube) {
	        this.parent = null;
	        this.lastMove = null;
	        this.depth = 0;
	        if (cube) {
	          this.init(cube);
	        }
	      }

	      State.prototype.init = function(cube) {
	        this.flip = cube.flip();
	        this.twist = cube.twist();
	        this.slice = cube.FRtoBR() / N_SLICE2 | 0;
	        this.parity = cube.cornerParity();
	        this.URFtoDLF = cube.URFtoDLF();
	        this.FRtoBR = cube.FRtoBR();
	        this.URtoUL = cube.URtoUL();
	        this.UBtoDF = cube.UBtoDF();
	        return this;
	      };

	      State.prototype.solution = function() {
	        if (this.parent) {
	          return this.parent.solution() + moveNames[this.lastMove] + ' ';
	        } else {
	          return '';
	        }
	      };

	      State.prototype.move = function(table, index, move) {
	        return Cube.moveTables[table][index][move];
	      };

	      State.prototype.pruning = function(table, index) {
	        return pruning(Cube.pruningTables[table], index);
	      };

	      State.prototype.moves1 = function() {
	        if (this.lastMove !== null) {
	          return nextMoves1[this.lastMove / 3 | 0];
	        } else {
	          return allMoves1;
	        }
	      };

	      State.prototype.minDist1 = function() {
	        var d1, d2;
	        d1 = this.pruning('sliceFlip', N_SLICE1 * this.flip + this.slice);
	        d2 = this.pruning('sliceTwist', N_SLICE1 * this.twist + this.slice);
	        return max(d1, d2);
	      };

	      State.prototype.next1 = function(move) {
	        var next;
	        next = freeStates.pop();
	        next.parent = this;
	        next.lastMove = move;
	        next.depth = this.depth + 1;
	        next.flip = this.move('flip', this.flip, move);
	        next.twist = this.move('twist', this.twist, move);
	        next.slice = this.move('FRtoBR', this.slice * 24, move) / 24 | 0;
	        return next;
	      };

	      State.prototype.moves2 = function() {
	        if (this.lastMove !== null) {
	          return nextMoves2[this.lastMove / 3 | 0];
	        } else {
	          return allMoves2;
	        }
	      };

	      State.prototype.minDist2 = function() {
	        var d1, d2, index1, index2;
	        index1 = (N_SLICE2 * this.URtoDF + this.FRtoBR) * N_PARITY + this.parity;
	        d1 = this.pruning('sliceURtoDFParity', index1);
	        index2 = (N_SLICE2 * this.URFtoDLF + this.FRtoBR) * N_PARITY + this.parity;
	        d2 = this.pruning('sliceURFtoDLFParity', index2);
	        return max(d1, d2);
	      };

	      State.prototype.init2 = function(top) {
	        if (top == null) {
	          top = true;
	        }
	        if (this.parent === null) {
	          return;
	        }
	        this.parent.init2(false);
	        this.URFtoDLF = this.move('URFtoDLF', this.parent.URFtoDLF, this.lastMove);
	        this.FRtoBR = this.move('FRtoBR', this.parent.FRtoBR, this.lastMove);
	        this.parity = this.move('parity', this.parent.parity, this.lastMove);
	        this.URtoUL = this.move('URtoUL', this.parent.URtoUL, this.lastMove);
	        this.UBtoDF = this.move('UBtoDF', this.parent.UBtoDF, this.lastMove);
	        if (top) {
	          return this.URtoDF = this.move('mergeURtoDF', this.URtoUL, this.UBtoDF);
	        }
	      };

	      State.prototype.next2 = function(move) {
	        var next;
	        next = freeStates.pop();
	        next.parent = this;
	        next.lastMove = move;
	        next.depth = this.depth + 1;
	        next.URFtoDLF = this.move('URFtoDLF', this.URFtoDLF, move);
	        next.FRtoBR = this.move('FRtoBR', this.FRtoBR, move);
	        next.parity = this.move('parity', this.parity, move);
	        next.URtoDF = this.move('URtoDF', this.URtoDF, move);
	        return next;
	      };

	      return State;

	    })();
	    solution = null;
	    phase1search = function(state) {
	      var depth, m, ref2, results;
	      depth = 0;
	      results = [];
	      for (depth = m = 1, ref2 = maxDepth; 1 <= ref2 ? m <= ref2 : m >= ref2; depth = 1 <= ref2 ? ++m : --m) {
	        phase1(state, depth);
	        if (solution !== null) {
	          break;
	        }
	        results.push(depth++);
	      }
	      return results;
	    };
	    phase1 = function(state, depth) {
	      var len, m, move, next, ref2, ref3, results;
	      if (depth === 0) {
	        if (state.minDist1() === 0) {
	          if (state.lastMove === null || (ref2 = state.lastMove, indexOf.call(allMoves2, ref2) < 0)) {
	            return phase2search(state);
	          }
	        }
	      } else if (depth > 0) {
	        if (state.minDist1() <= depth) {
	          ref3 = state.moves1();
	          results = [];
	          for (m = 0, len = ref3.length; m < len; m++) {
	            move = ref3[m];
	            next = state.next1(move);
	            phase1(next, depth - 1);
	            freeStates.push(next);
	            if (solution !== null) {
	              break;
	            } else {
	              results.push(void 0);
	            }
	          }
	          return results;
	        }
	      }
	    };
	    phase2search = function(state) {
	      var depth, m, ref2, results;
	      state.init2();
	      results = [];
	      for (depth = m = 1, ref2 = maxDepth - state.depth; 1 <= ref2 ? m <= ref2 : m >= ref2; depth = 1 <= ref2 ? ++m : --m) {
	        phase2(state, depth);
	        if (solution !== null) {
	          break;
	        }
	        results.push(depth++);
	      }
	      return results;
	    };
	    phase2 = function(state, depth) {
	      var len, m, move, next, ref2, results;
	      if (depth === 0) {
	        if (state.minDist2() === 0) {
	          return solution = state.solution();
	        }
	      } else if (depth > 0) {
	        if (state.minDist2() <= depth) {
	          ref2 = state.moves2();
	          results = [];
	          for (m = 0, len = ref2.length; m < len; m++) {
	            move = ref2[m];
	            next = state.next2(move);
	            phase2(next, depth - 1);
	            freeStates.push(next);
	            if (solution !== null) {
	              break;
	            } else {
	              results.push(void 0);
	            }
	          }
	          return results;
	        }
	      }
	    };
	    freeStates = (function() {
	      var m, ref2, results;
	      results = [];
	      for (x = m = 0, ref2 = maxDepth + 1; 0 <= ref2 ? m <= ref2 : m >= ref2; x = 0 <= ref2 ? ++m : --m) {
	        results.push(new State);
	      }
	      return results;
	    })();
	    state = freeStates.pop().init(this);
	    phase1search(state);
	    freeStates.push(state);
	    if (solution.length > 0) {
	      solution = solution.substring(0, solution.length - 1);
	    }
	    return solution;
	  };

	  Cube.scramble = function() {
	    return Cube.inverse(Cube.random().solve());
	  };

	}).call(this);


/***/ })
/******/ ]);